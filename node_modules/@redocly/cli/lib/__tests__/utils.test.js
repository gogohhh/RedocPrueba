"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../utils");
const colorette_1 = require("colorette");
jest.mock('os');
jest.mock('colorette');
describe('isSubdir', () => {
    it('can correctly determine if subdir', () => {
        [
            ['/foo', '/foo', false],
            ['/foo', '/bar', false],
            ['/foo', '/foobar', false],
            ['/foo', '/foo/bar', true],
            ['/foo', '/foo/../bar', false],
            ['/foo', '/foo/./bar', true],
            ['/bar/../foo', '/foo/bar', true],
            ['/foo', './bar', false],
            ['/foo', '/foo/..bar', true],
        ].forEach(([parent, child, expectRes]) => {
            expect(utils_1.isSubdir(parent, child)).toBe(expectRes);
        });
    });
    it('can correctly determine if subdir for windows-based paths', () => {
        const os = require('os');
        os.platform.mockImplementation(() => 'win32');
        [
            ['C:/Foo', 'C:/Foo/Bar', true],
            ['C:\\Foo', 'C:\\Bar', false],
            ['C:\\Foo', 'D:\\Foo\\Bar', false],
        ].forEach(([parent, child, expectRes]) => {
            expect(utils_1.isSubdir(parent, child)).toBe(expectRes);
        });
    });
    afterEach(() => {
        jest.resetModules();
    });
});
describe('pathToFilename', () => {
    it('should use correct path separator', () => {
        const processedPath = utils_1.pathToFilename('/user/createWithList', '_');
        expect(processedPath).toEqual('user_createWithList');
    });
});
describe('printConfigLintTotals', () => {
    const totalProblemsMock = {
        errors: 1,
        warnings: 0,
        ignored: 0,
    };
    const redColoretteMocks = colorette_1.red;
    const yellowColoretteMocks = colorette_1.yellow;
    beforeEach(() => {
        yellowColoretteMocks.mockImplementation((text) => text);
        redColoretteMocks.mockImplementation((text) => text);
        jest.spyOn(process.stderr, 'write').mockImplementation(() => true);
    });
    it('should print errors if such exist', () => {
        utils_1.printConfigLintTotals(totalProblemsMock);
        expect(process.stderr.write).toHaveBeenCalledWith('❌ Your config has 1 error.\n');
        expect(redColoretteMocks).toHaveBeenCalledWith('❌ Your config has 1 error.\n');
    });
    it('should print warnign and error', () => {
        utils_1.printConfigLintTotals(Object.assign(Object.assign({}, totalProblemsMock), { warnings: 2 }));
        expect(process.stderr.write).toHaveBeenCalledWith('❌ Your config has 1 error and 2 warnings.\n');
        expect(redColoretteMocks).toHaveBeenCalledWith('❌ Your config has 1 error and 2 warnings.\n');
    });
    it('should print warnign if no error', () => {
        utils_1.printConfigLintTotals(Object.assign(Object.assign({}, totalProblemsMock), { errors: 0, warnings: 2 }));
        expect(process.stderr.write).toHaveBeenCalledWith('You have 2 warnings.\n');
        expect(yellowColoretteMocks).toHaveBeenCalledWith('You have 2 warnings.\n');
    });
    it('should print nothing if no error and no warnings', () => {
        const result = utils_1.printConfigLintTotals(Object.assign(Object.assign({}, totalProblemsMock), { errors: 0 }));
        expect(result).toBeUndefined();
        expect(process.stderr.write).toHaveBeenCalledTimes(0);
        expect(yellowColoretteMocks).toHaveBeenCalledTimes(0);
        expect(redColoretteMocks).toHaveBeenCalledTimes(0);
    });
});

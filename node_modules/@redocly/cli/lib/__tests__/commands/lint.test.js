"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const lint_1 = require("../../commands/lint");
const openapi_core_1 = require("@redocly/openapi-core");
const utils_1 = require("../../utils");
const config_1 = require("../fixtures/config");
const perf_hooks_1 = require("perf_hooks");
jest.mock('@redocly/openapi-core');
jest.mock('../../utils');
jest.mock('perf_hooks');
const argvMock = {
    entrypoints: ['openapi.yaml'],
    'lint-config': 'off',
    format: 'codeframe',
};
const versionMock = '1.0.0';
describe('handleLint', () => {
    let processExitMock;
    let exitCb;
    const getMergedConfigMock = openapi_core_1.getMergedConfig;
    beforeEach(() => {
        jest.spyOn(process.stderr, 'write').mockImplementation(() => true);
        perf_hooks_1.performance.now.mockImplementation(() => 42);
        processExitMock = jest.spyOn(process, 'exit').mockImplementation();
        jest.spyOn(process, 'once').mockImplementation((_e, cb) => {
            exitCb = cb;
            return process.on(_e, cb);
        });
        getMergedConfigMock.mockReturnValue(config_1.ConfigFixture);
        openapi_core_1.doesYamlFileExist.mockImplementation((path) => path === 'redocly.yaml');
    });
    afterEach(() => {
        getMergedConfigMock.mockReset();
    });
    describe('loadConfig and getEnrtypoints stage', () => {
        it('should fail if config file does not exist', () => __awaiter(void 0, void 0, void 0, function* () {
            yield lint_1.handleLint(Object.assign(Object.assign({}, argvMock), { config: 'config.yaml' }), versionMock);
            expect(utils_1.exitWithError).toHaveBeenCalledWith('Please, provide valid path to the configuration file');
            expect(openapi_core_1.loadConfig).toHaveBeenCalledTimes(0);
        }));
        it('should call loadConfig and getFallbackEntryPointsOrExit', () => __awaiter(void 0, void 0, void 0, function* () {
            yield lint_1.handleLint(argvMock, versionMock);
            expect(openapi_core_1.loadConfig).toHaveBeenCalledWith(undefined, undefined, undefined);
            expect(utils_1.getFallbackEntryPointsOrExit).toHaveBeenCalled();
        }));
        it('should call loadConfig with args if such exist', () => __awaiter(void 0, void 0, void 0, function* () {
            yield lint_1.handleLint(Object.assign(Object.assign({}, argvMock), { config: 'redocly.yaml', extends: ['some/path'] }), versionMock);
            expect(openapi_core_1.loadConfig).toHaveBeenCalledWith('redocly.yaml', ['some/path'], undefined);
        }));
        it('should call mergedConfig with clear ignore if `generate-ignore-file` argv', () => __awaiter(void 0, void 0, void 0, function* () {
            yield lint_1.handleLint(Object.assign(Object.assign({}, argvMock), { 'generate-ignore-file': true }), versionMock);
            expect(getMergedConfigMock).toHaveBeenCalled();
        }));
    });
    describe('loop through entrypints and lint stage', () => {
        it('should call getMergedConfig and lint ', () => __awaiter(void 0, void 0, void 0, function* () {
            yield lint_1.handleLint(argvMock, versionMock);
            expect(perf_hooks_1.performance.now).toHaveBeenCalled();
            expect(getMergedConfigMock).toHaveBeenCalled();
            expect(openapi_core_1.lint).toHaveBeenCalled();
        }));
        it('should call skipRules,skipPreprocessors and addIgnore with argv', () => __awaiter(void 0, void 0, void 0, function* () {
            openapi_core_1.lint.mockResolvedValueOnce(['problem']);
            yield lint_1.handleLint(Object.assign(Object.assign({}, argvMock), { 'skip-preprocessor': ['preprocessor'], 'skip-rule': ['rule'], 'generate-ignore-file': true }), versionMock);
            expect(config_1.ConfigFixture.lint.skipRules).toHaveBeenCalledWith(['rule']);
            expect(config_1.ConfigFixture.lint.skipPreprocessors).toHaveBeenCalledWith(['preprocessor']);
        }));
        it('should call formatProblems and getExecutionTime with argv', () => __awaiter(void 0, void 0, void 0, function* () {
            openapi_core_1.lint.mockResolvedValueOnce(['problem']);
            yield lint_1.handleLint(Object.assign(Object.assign({}, argvMock), { 'max-problems': 2, format: 'stylish' }), versionMock);
            expect(openapi_core_1.getTotals).toHaveBeenCalledWith(['problem']);
            expect(openapi_core_1.formatProblems).toHaveBeenCalledWith(['problem'], {
                format: 'stylish',
                maxProblems: 2,
                totals: { errors: 0 },
                version: versionMock,
            });
            expect(utils_1.getExecutionTime).toHaveBeenCalledWith(42);
        }));
        it('should catch error in handleError if something fails', () => __awaiter(void 0, void 0, void 0, function* () {
            openapi_core_1.lint.mockRejectedValueOnce('error');
            yield lint_1.handleLint(argvMock, versionMock);
            expect(utils_1.handleError).toHaveBeenCalledWith('error', '');
        }));
    });
    describe('erros and warning handle after lint stage', () => {
        it('should call printLintTotals and printLintTotals', () => __awaiter(void 0, void 0, void 0, function* () {
            yield lint_1.handleLint(argvMock, versionMock);
            expect(utils_1.printUnusedWarnings).toHaveBeenCalled();
        }));
        it('should call exit with 0 if no errors', () => __awaiter(void 0, void 0, void 0, function* () {
            yield lint_1.handleLint(argvMock, versionMock);
            exitCb === null || exitCb === void 0 ? void 0 : exitCb();
            expect(processExitMock).toHaveBeenCalledWith(0);
        }));
        it('should exit with 1 if tootals error > 0', () => __awaiter(void 0, void 0, void 0, function* () {
            openapi_core_1.getTotals.mockReturnValueOnce({ errors: 1 });
            yield lint_1.handleLint(argvMock, versionMock);
            exitCb === null || exitCb === void 0 ? void 0 : exitCb();
            expect(processExitMock).toHaveBeenCalledWith(1);
        }));
    });
});
